

## 변경 사항 및 트러블 슈팅 ##
### USER와 친구요청 ###
  - 우선 친구 추가 방식을 어떤식으로 할지 생각해보았습니다... 친구 요청을 보내서 수락을 해야 받는 형식으로 할지 단방향으로 할지
  - 일단 첫번쨰,  user 객체 하나는 다수의 친구를 가질수있고 친구요청과,보낸요청을 가질수있습니다 전부 일대다 관계,
  - 친구요청은  FRIENDREQ 의 레코드 생성을 보낸 사람은 user(sender) 받는 사람도 user(sender) 여기서 Sender도 user고 reciever도 user입니다 수락을 하게되면 ENUMARATE 필드를 통해 친구 관계가 정의되고 레코드가 추가됩니다..를 생각하며 
  - 샘플데이터로 친구요청 레코드와 친구 레코드를 임의로 넣어보았는데 결국 sender는 user를 참조하고 sentedReq(내가 보낸 요청) 도 friendReq 서로가 서로를 참조하면서 순환참조 문제가 생겼습니다... 

  #### 해결방안
      - 친구요청 기능의 필요성을 생각해보았는데요.
      - 요즘 왠만한 sns는 친구요청이라는걸 따로 수락과 대기중을 나누지 않는다,, 라는걸 생각해보면
      - a가 b를 추가하게되면 b는 알필요가없다 b는 그냥 나를 추가한사람 정도로만 알면된다 라고생각을 해봤습니다
      - 그래서 user객체의 기존 일대다 관계필드를 지우고 Friends테이블에 추가한사람 추가 당하는사람 을 다대일로, 하게되면
      - a가 b를 추가할때  a는 본인의 id값이 friends테이블에 컬럼(addedby)에 fk로 추가되고 당하는 b는 컬럼(youadded)에 fk로 속하게 되기 떄문에
      - a가 친구목록을 조회할때는 addedBy의 컬럼 값이 본인의 id값인것만 조회하면 될것이고 b는 youadded로 본인을 추가한 사용자를 추가로 확인가능합니다,
      - 테이블간의 관계가 단방향이기 때문에 직관적이고 좀더 보기도 다루기도 간편하고 좋은거같습니다 ㅎㅎ 순환참조 문제도 발생하지않았고 이로써 해결하였습니다.



### JWT인증방식 ###
  - 세션기반 로그인방식이 간편하고 참좋다고 생각을 하였는데요.
    무상태성을 원칙으로가지는 RestFul API 설계 원칙에 맞지않았기도 하고 세션 자체를 서버에서 관리하다보니 사용자가 늘어나게 된다면 과부하가 염려되었습니다.
  - 일단 secret키를 keygen.class를 따로 만들고 securerandom과 byte를 사용하여 32바이트 난수를 생성해주었고 이를 Base64로 인코딩하여 환경변수로 등록을 해주었고,
  - 이후에 jwtUtil에서는 이 키를 디코딩하여 시그니쳐키로 사용할수있게하였습니다,,  토큰 발급과 검증 메서드 그리고 재발급을 위한 리프레시토큰 발급 메서드를 정의해주었고,
  - 클라이언트에서는 login시에 검증후에 액세스토큰과 리프레시토큰을 로컬스토리지에 저장하였습니다.

    ##### 문제점 : 이후에 로그인 상태를 서버에서 이제 알려주지않기에 새로고침을하게되면 다시 로그인을 해야하는 상황이 일어났습니다...
 

  #### 해결방안 
       - 앞서 로컬스토리지에 저장한 토큰을 checLogin이라는 api를 만들어 인증과 유저정보가 필요한곳에서 호출되게 하였습니다..
       - 처음에는 단순  fetch  API를 사용하여 요청으로 헤더에 토큰값과 리프레시토큰값을 보내
       - 서버에서는 토큰의 유효성검사를 진행하고 response에 토큰값과 userId를 보내주었습니다.  
       - 응답을 받고 응답을 json파싱후 data로 쓰려하니 응답결과에는 항상 null이 반환되었고 알고보니 이또한 fetch요청이 완료되기전에 data를 파싱하려했다는점에서
       - 문제가 발생하였기에 async와 안에서 쓸수있는 await 를 사용하여 완전히 요청이 완료될때까지 data를 다룰수 없게 하였습니다.
       - 요청데이터가 정상적이면 return { loggedIn: true, userId: data.userId }; 이렇게 생성해주었고 
       - 이후에는 요청의 응답이 json형태로 userid와 토큰의 값이 클라이언트측으로 보여지게 되었고 이를 이용하여 인증이 필요한 /main
       - 엔드포인트에서 사용하여 인증을 정상적으로 할수있게되었습니다.

        

### 친구 검색 ###
  - 친구를 추가를 하기에도 친구를 조회하기에도 좋게 검색 기능을 구현했습니다.
  - 인풋에 네임 밸류가 search api에서 파라미터값으로 들어가게되고 네임을 통하여 db 조회후 해당 객체를 반환했습니다.

  ##### 문제점 : user객체 자체를 반환하다보니 필요없는 정보와 민감한정보까지 다 json형식으로 클라이트에서 확인 가능했습니다.


#### 해결방안
     - 필요한정보만 서비스 계층에서 보내야하기때문에 UserDto를 만들어주게 되었습니다 이름,email,Id 필드를 정의해주었고
       기존 user객체 자체를 반환하는 서비스 메서드에서 user객체에서 필요한 정보만 get하여 DTO객체로 만들어주었고,
       클라이언트 측도 이젠 민감한정보를 반환하지 않았습니다.
    
