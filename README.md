

# 변경 사항 및 트러블 슈팅 #

## 변경사항 및 추가 목록 #

### 1 . 웹소켓 api를 이용한 실시간 채팅 ###
### 2 . 메세지 텍스트 OPENAI API 를 이용한 감정분석 ###
### 3 . 채팅방 리스트 메세지 리스트 조회 ###
### 4 . 채팅방 조회 및 메세지 전송시 채팅방 자동 생성  ###
### 5 . 메세지 실시간 읽음 처리 , 뮤테이션 옵져버를 이용한 실시간 요소 추적  ###


## 트러블 슈팅

### 1 . 웹소켓 실시간 양방향 통신 ###
      기존 세션 기반의 로그인 시스템과 동일하다고 생각했으나 이는 오산이었습니다.
      세션 기반의 로그인 방식은 HTTP통신이었으나 웹소켓은 첫 연결시에는 http통신 그후는 연결이 업그레이드되어  끊어지지 않는 다는 특징이 있었습니다.
      하지만 Stomp방식의 세션 자동 설정으로 인한 세션의 정보가 null로 나오는 문제점이있었습니다.
      기존에 만들고자했던것은 Stomp방식으로 메세지의 도착지점을 구독 하는 형식이었으나
      세션의 정보가 자동으로 설정이 되기는 하나 메세지를 해당 destination에 전송을 하면 해당 destination을 구독하고 연결이 open되어있는 user의 세션이
      null로 나오기에 대상의 세션에게는 메세지 전송이 불가능하였습니다.
        
  #### 해결 과정
      stomp의 구조를  잘몰라서 그런진 모르겠으나 그냥 WebSocet API 만을 이용하기로 하였습니다.
      세션 관리 각 채팅방, 사용자별로 메세지 발행을 하고 웹소켓 통신으로 업그레이드 되기전에 핸드셰이크 인터셉터의 BeforeHandShake 를 오버라이딩 해주었습니다.
      연결시 보내는 파라미터값에 담긴 jwt를 검증하고 email을 추출하여 세션에 userEmail을 추가 그후 유저 세션의 정보를 담아줄 Map 객채 userSessions를 만들어
      안에 넣어주었습니다. 이후 세션간 통신을 위해서 MyWsHandler라는 서비스 클래스를 만들고 /ws-login으로 웹소켓 연결이 들어올때 MyWsHadler로 핸들링하겠다고 명시해주었고
      이후 앞서 만든 인터셉터를 추가해 연결되기전 세션의 정보를 명시적으로 설정해주었습니다. 이제 연결이 들어오고 MyWsHadler에서는 연결이 성립되기전 세션을 wsSessionManager라는 클래스로
      세션을 등록해주었고 클라이언트에서 메세지를 보낼때는 type과 sender의 이메일 content 내용 receipmentEm을 명시하여 json형식으로 보내주게됩니다.
      이후 필요한 정보들의 값을 파싱해주어 상대세션을 찾고 상대세션에게 제이슨 오브젝트인 msgObj를 만들고  전달해줘야할  메세지를 담아 전송해주니 성공하게되었습니다.
      이과정에서 OPENAI API를 이용하여 감정 분석을 위한 프롬프트를 작성해주었고
      상대 세션에게 msgObj 에는 감정분석결과를 받고 담아준 String 오브젝트를 추가해주었고 클라이언트 측에서도 확인이 가능하였습니다
      
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------           

### 3 .채팅방 리스트 조회 , 메세지 리스트 조회; ###
      기존에 Chatroom 과 User를 이어주는 조인테이블 RoomInUser를 통해 채팅방에 user를 연결해주는 것은 성공했고
      채팅방 목록을 조회하는 api를 호출하는 스크립트를 정의해주고 조회시 fetch요정으로 data의 정보를 추출하여 ui를 업데이트 하려했습니다.
      이 과정에서 들어왔던 data의 콘솔로그를 확인해보니 roomInUser가 무한히 반복되는 순환참조 현상이 일어났습니다.
      
  
 #### 해결 과정
      chatroom은 roominuser를 통해 user를 조회하고 user는 roomInUser를 통해 chatroom을 조회
      이렇다보니 순환참조를 하는 문제가 생겼습니다. 결국 해결책으로 DTO객체를 만들었고 RoomInUser 객체 리스트를  user의 프라이머리키를 이용하여 조회후 담고 , 이후  UserDTO 클래스를 작성후 필요한 정보를 담을 필드를 정의한후
      RoomInUser의 정보를 UserDto로 변환했고,  기존 Chatroom 객체도 RoomDTO를 작성해서 기존 Chatroom 의 RoomInUser필드를 UserDTo로 정의 이후 앞서 변환해서 만든 UserDTO를 RoomDTO에 담아 반환되게하니 조회가 잘 
      되는걸 확인했습니다.![image](https://github.com/user-attachments/assets/fe055c30-b236-431f-9c2a-02a222a51a42)

      같은 원리로 메세지 또한 user의 정보를 담고있기때문에 messageDTO를 통해 순환참조 현상을 해결하였습니다.

      
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     

### 4 . 채팅방 조회 및 메세지 전송시 채팅방 자동 생성 ###
    1번 문제 : 메세지 전송시에 대상이 되는 user와의 연결된 채팅방이 없으면 메세지 전송후 저장이 불가하기에
              메세지를 클라이언트측에 전달하기전에 기존 채팅방이있는지 없는지 검증을 ChatService클래스에 메소드로 정의해주었습니다.
              이때 alice가 bob에게 첫 메세지 전송을 하고 bob도 alice에게 첫 메세지 전송을 하게되면 동시에 chatroom을 만들었고 중복 되는 행이 생성되었습니다.

    2번 문제 : 채팅방 생성후 메세지를 보내면 상대 클라이언트의 ui는 그대로이기에 내가 누구에게 새로운 메세지를 받았는지 알수가 없었습니다.
    


  ### 해결 과정
    1번 문제 해결과정 : 메세지 전송시 해당유저와 내가 연결된 chatroom이 없다면 만드는 메소드를 정의해주었다고 했습니다.
                      그 메소드에서 synchronized 키워드를 사용하여 리포지토리에 저장하는 코드들을 감싸주었고 한번에 하나의 쓰레드만 접근가능하게 해주니 
                      이후에는 중복 행 생성이 되지 않았습니다.

    2번 문제 해결과정 : 메세지 전송시 첫 메세지를 보내면 앞서 설명했던 새로운 채팅방을 만들고 해당 메세지를 저장해준다고 했습니다.
                       하지만 이를 메세지를 받게될 상대와 본인은 채팅방의 생성 여부와 메세지의 수신 발신 여부가 ui로 알려주지 못했습니다.
                       그래서 양방향 통신의 특징을 이용하여 새로운 채팅방을 만들게 된다면 보내게 될 msgObj 제이슨 객체에다가 type이라는 프로퍼티를 설정해주고 거기에 newOne이라는 구분을
                       만들어주엏고 웹소켓의 연결과 메세지 수신시 정의 되어있던 스크립트에 newOne을 감지후 roomList api를 호출해주었고 이후 채팅방의 생성과 메세지의 수신을 실시간으로 할수있게
                       되었습니다.



### 5 . 메세지 실시간 읽음 처리 , 뮤테이션 옵져버를 이용한 실시간 요소 추적 ###
     상대가 메세지를 읽었는지 안읽었는지 알수있는 방법이 뭐가있을까 생각해보던 중
     채팅방 조회 함수가 실행 될 적에 서버로 웹소켓 메세지를 보내는게 어떨까 라는 생각이 들어 해보았습니다.
     채팅방 조회 함수가 실행되면 msg에는 { type : "enter" (들어간다는 명시) , roomId : (채팅방의 id) , receiver : (해당채팅방에 내가아닌 유저 즉 메세지를 받게될 유저의 email), sender : (checkLogin함수를 호출하여 현재 로그인한 유저의 email) }를 
     서버로 보내게됩니다.  이때 서버에서는 sender(접속한 본인) 가 room에 들어갔다 라는걸 알려주기위해 roomSession이라는 Map객체를 만들고 접속한 세션과 roomId를  해당 roomSession에 추가해주었습니다. 또한 상대 세션도 roomId를 구분하여 해당 roomSession 에 추가가되고 
     메세지를 보낼 대상이 될 user의 세션이 roomSession에 있는지 검증후 boolean 값을 리턴하게 만들어주었습니다. 이후에 상대 클라이언트에 type : "status" , doesSheInroom : true  라는 상태를 알려주기위한 메세지를 전달하며 클라이언트는 해당 메세지를 이용하여 true일 경우에
     옵져버를 시작 호출하여 시작합니다. 옵져버에서는 내가 보낼 메세지들의 엘리먼트들을 추적하여 밑에 읽음이라는 표시를 생성후 3초뒤에 없어지게 만들어주었습니다.
     문제는 메세지 전송시 엘리먼트를 만들고 추적하는 과정에서 먼저 입장한 클라이언트의 경우 상대가 메세지를 읽음 표시를 확인 가능, 상대 클라이언트는 내가 메세지를 읽었는지 안읽었는지 확인 불가능 했습니다.


  ### 해결 과정
    의외로 간단한 이유였습니다 상대가 나에게 채팅방에 들어왔다고 서버에서 클라이언트로 알려주는데 상대는 내가 들어와있다는걸 전달 받지 못했기때문입니다.
    그래서 대상세션에게만 status를 담은 msg를 전송하던 것을 입장하는 본인의 세션에게도 알려주었습니다.  이러니 뮤테이션 옵져버가 클라이언트 별로 잘 작동하였습니다.

      
      


     
    
    
